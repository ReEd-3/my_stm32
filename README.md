# my_stm32

## Tips

- 2025.11.04  
    1. keil无法对**国产芯片**识别，可以连接但不能烧录。  
    2. stm32f1c103c8t6默认LED连接PC13(或PB12)。  

- 2025.11.05  
    1. 保证电路处处通路，尤其是排针与系统板接触。  
    2. 四脚按键同侧两脚相连  

- 2025.11.06  
    1. PWM含有三个重要参数  
        - 频率  
        - 周期  
        - 占空比  
    2. PWM可以通过控制**高低电平占比**来控制LED亮度  
    3. 呼吸灯的流畅程度和arr有很大关系  
    4. ccr的数值决定了PWM的占空比  
    5. **duty**(占空比)和arr,ccr之间满足**ccr = duty * (arr+1)**  

- 2025.11.07
    1. 舵机旋转的流畅程度也和arr有很大关系
    2. PWM信号频率 = 时钟频率 ÷ psc ÷ arr (这表明了arr越PWM信号频率越小输出越不流畅)  

- 2025.11.08
    1. 按键控制中GPIO_INPUT需要设置为**上拉(Pull up)**
    2. 编写大型工程时将**功能模块化**很重要，边编写边测试，可以利用默认LED指示灯用于测试
    3. 为程序设置**状态机**可以有效实现对复杂情况的处理
    4. 对双击操作进行消抖时要保证第二次点击充分消抖防止双击后单击

- 2025.11.09
    1. stm32系统板上的**TX，RX**分别和USB转TTL上的**RXD，TXD**连接
    2. 非阻塞中使用**HAL\_TIM\_PeriodElapsedCallback(TIM\_HandleTypeDef \*htim)**
    和**HAL\_UART\_TxCpltCallback(UART\_HandleTypeDef \*huart)**进行回调函数调用（计时器arr每溢出一次进行一次回调）
    3. 阻塞编程中需要设置**timeout**防止程序被一直截断

- 2025.11.10
    1. **空闲中断(IDLE)**不会自动清除，需要手动清除，不清除会导致**反复进入空闲中断**
    2. 进入空闲中断使用
        ```c
        void USART1_IRQHandler(void)
        {
            if (__HAL_UART_GET_FLAG(&huart1, UART_FLAG_IDLE) != RESET){//空闲中断
                /* 代码部分 */
            }
        HAL_UART_IRQHandler(&huart1);
        }
        ```
        这段代码原型放在**stm32f1xx_it.c**中
    3. 不要使用`memset`格式化字符串，会出现无法输出问题
    4. 在空闲中断中使用`HAL_UART_AbortReceive_IT(&huart1);`中断接收，否则会导致第二次入时**首个字符丢失**的情况

- 2025.11.13
    1. 在DMA中接收数据时，DMA指向一个缓冲区(一个uint8_t数组)，在缓冲区中进行数据的写入，缓冲区将要溢出时会从缓冲区头部进行写入
        例如
        ```text
        
        最开始          输入“114514”            输入“0721”
        DMA                  DMA                 DMA
        |                    |                   |
        V                    V                   V
        --------        114514--                21451407
        ```
    2. 可以使用`HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_13)`翻转板载LED灯的电平进行调试(例如观察是否进入FreeRTOS，是否发生了中断，是否进入了循环)
    3. FreeRTOS中的不同线程有优先级之分，需要确保并行的线程优先级相同
    4. 空闲中断中使用`__HAL_DMA_DISABLE(huart1.hdmarx)`停用DMA后，再次打开DMA需要用`__HAL_DMA_ENABLE(huart1.hdmarx)`, 
    如果使用`HAL_UART_Receive_DMA(&huart1, rx_buffer, sizeof(rx_buffer))`直接再次启用DMA会导致后续传输的数据出错(传输新的数据返回旧的数据，传输多次才能返回新的的数据)
    5. FreeRTOS可以在**freertos.c**中建立多个线程，在调用`osKernelStart()`之后程序会忽视main中的内容，执行**freertos.c**中的线程 
    freertos和SYS时钟源需要配置不同的时钟，例如一个使用系统时钟另一个使用TIM1， 
    freertos中进行阻塞需要使用`osDelay()`


## Files

### 基础外设掌控（硬件交互）

1. LED001
    - 实验性工程，PB8以1Hz实现高低电平翻转  

2. LED002
    - 实验性工程，PC13和PB12以1Hz实现高低电平翻转  

3. LED003
    - 开关连接PB8控制LED的点亮和熄灭，使开关按下一次LED转换一次状态，  
    PC13控制默认LED的状态使开关按下时默认LED熄灭，其余时刻点亮  

4. Breath_LED  
    - 呼吸灯，使LED亮度随着时间成正弦变化，代码块中使用for循环和delay使时间i递增,  
    用sin函数计算渐亮时的ccr，cos函数计算渐暗时的ccr  

5. Servo_control
    - 舵机控制，通过**PWM**控制舵机旋转到0°，90°，180°，间隔1s  
    - 还可以通过**for循环**控制舵机的转动速度（见while循环中注释掉的代码）

6. SERVO_KEY  
    - 按键实现舵机特定角度的控制，为按键状态和事件状态设置了多种状态
    - 执行过程可分为
        1. 检测**按键状态**
        2. 根据**按键状态**设置不同的**按键事件**
        3. 根据**按键事件**进行**舵机位置**的控制
        4. 根据舵机位置输出相应的**PWM**

### 串口通信与优化（人机交互）

1. USART
    - 简单的串口通信，程序执行时使用`HAL_UART_Transmit_IT(&huart1, 字符串名称, 字符串长度，timeout)`阻塞的方法发送`"hello world"`

2. Time_Transmit
    - 根据时钟进行时间数据的传输，每**1/10秒**传输一次系统时间，
    - 执行过程分为
        1. **时钟2**进行回调时，**系统时间**+1，**时钟状态**变为可用
        2. **USART1**进行回调时，**串口状态变**为可用
        3. 如果**时钟状态**和**串口状态**均可用，则计算出时分秒的数值，**格式化字符**串生成时间，并发送

3. LED_Command
    - 上位机使用**VOFA+**发送命令"ON","OFF",使PC13连接的LED相应开关并相应返回"LED_ON","LED_OFF"
    - 执行过程分为
        1. 打开**接收回调**，将输入的数据保存在`rx_buffer`中
        2. 对比`rx_buffer`中的数据和命令，如果输入的是命令则执行相应的代码
    - 要注意在读取到`\n`时在`rx_buffer`末尾加`\0`

4. Idle_Interruption
    - 使**用接收中断**和**空闲中断**，将输入的值原封不动返回
    - 执行过程分为
        1. 打开**接收中断回调**和**空闲中断回调**
        2. 接收到数据时，将每个字节存放在缓冲区(这将触发若干次接收中断)，最后触发一次空闲中断回调，结束传输
        3. 在主循环中向上位机发送刚刚传输的数据

5. DMA_IO
    - 使**DMA接收数据**和**空闲中断**，将输入的值原封不动返回
    - 执行过程与**4**类似，但是不需要对接收中断进行处理，接收数据由****DMA**完成
    - 使用注意事项见**2025.11.13**

### 引入实时操作系统（系统整合）

1. FreeRTOS
    - 使用**STM32CUBEMX**开启FreeRTOS，保证两个并行线程之间优先级相等
    - 编写**呼吸灯**程序和**DMA接收并处理数据**程序